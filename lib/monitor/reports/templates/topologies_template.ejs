<script>
  var entries = <%- JSON.stringify(entries) %>;
  var names = [<%- Object.keys(entries).map(function(x) { return '"' + x + '"'; }).join(',') %>];
</script>

<!-- Graphics container -->
<div class='container'>
  <h1>Server Topology Graphs</h1>
  <% for(var member in entries) { %>
    <h2><%= member %></h2>
    <% 
      var keys = Object.keys(entries[member]);
      var numberOfEntries = entries[member][keys[0]].length;
    %>
    <% if(numberOfEntries == 1) { %>
      <div id="<%= member %>_ops_graph"></div>
    <% } %>
    <% if(numberOfEntries > 1) { %>
      <table width="100%">
        <tr>
          <td>
            <h3>Aggregated Operation Counters</h3>
            <div id="<%= member %>_ops_graph"></div>
          </td>
          <td>
            <h3><%= entries[member][keys[0]][0].server %></h3>
            <div id="<%= member %>_ops_graph_0"></div>
          </td>
        </tr>
        <% for(var i = 1; i < numberOfEntries; i++) { %>
        <tr>
          <td></td>
          <td>
            <h3><%= entries[member][keys[0]][i].server %></h3>
            <div id="<%= member %>_ops_graph_<%= i %>"></div>
          </td>
        </tr>
        <% } %>
      </table>
    <% } %>
  <% } %>
</div>

<!-- Graph generation -->
<script>
var generateGraph = function(container, groupEntries, data, transform) {
  // Create a dataset with items
  var dataset = new vis.DataSet({
    type: {start: 'ISODate', end: 'ISODate' }
  });

  // Start and end point
  var startPoint = Number.MAX_VALUE;
  var endPoint = 0;

  // Clear the data set
  dataset.clear();

  // Create the groups
  var groups = new vis.DataSet();
  // Add the group entries
  for(var i = 0; i < groupEntries.length; i++) {
    groups.add(groupEntries[i]);
  }

  // Data array
  var dataArray = [];
  var i = 0;

  // Iterate over all the data
  for(var timestamp in data) {
    // Extract the data
    var extractedPoint = transform(data[timestamp]);
    // Skip the first result
    if(extractedPoint == null) continue;

    // Parse timestamp
    var date = moment(timestamp);
    var unixTime = date.unix();
    // Set date by unix time
    date = new Date();
    date.setTime(unixTime);

    // Adjust start and end point
    if(date.getTime() < startPoint) startPoint = date;
    if(date.getTime() > endPoint) endPoint = date;

    // For each point extract the values
    for(var name in extractedPoint) {
      dataArray.push({
        id: i++, x: date, y: extractedPoint[name], group: name
      });      
    }
  }

  // Graph charting examples
  var options = {
    defaultGroup: 'ungrouped',
    legend: true,
    sampling: true,
    catmullRom: false,
    start: moment(startPoint),
    end: moment(endPoint),
    height: 200,
    width: 400,
    clickToUse: true
  };

  // Add the data
  dataset.add(dataArray);
  // Create graph
  var graph2d = new vis.Graph2d(container, dataset, groups, options);
}
</script>

<!-- Generate graphs -->
<script>
  // Generate ops graphs
  <% for(var member in entries) { %>
    var member = '<%- member %>';
    // Get the ops container
    var container = document.getElementById(member + "_ops_graph");
    // The last measurement
    var lastMeasurement = null;
    // Generate groups
    var groupNames = ['insert', 'query', 'update', 'delete', 'getmore', 'command'];
    var groups = groupNames.map(function(x) {
      return {id: x, content: x, options: {}};
    });

    // How many entries do we have
    var keys = Object.keys(entries[member]);
    var numberOfEntries = entries[member][keys[0]].length;

    // Generate the totals graph
    generateGraph(container, groups, entries[member], function(data) {
      var opcounters = {};
      for(var i = 0; i < groupNames.length; i++) {
        opcounters[groupNames[i]] = 0;
      }

      // Add all the values
      for(var i = 0; i < data.length; i++) {
        var ops = data[i].result.opcounters;
        // Add up all the ops
        for(var name in opcounters) {
          opcounters[name] += ops[name];
        }
      }

      // Throw away the first result
      if(lastMeasurement == null) {
        lastMeasurement = opcounters;
        return null;
      }

      // Final Ops counters
      var finalValues = {}
      // Calculate the diff between the two (actual ops that happened)
      for(var name in opcounters) {        
        finalValues[name] = opcounters[name] - lastMeasurement[name];
      }

      // Update last measurement
      lastMeasurement = opcounters;
      // Return the values
      return finalValues;
    });

    // If we have replicaset members render them
    if(numberOfEntries > 1) {      
      // Iterate over all the entries
      for(var i = 0; i < numberOfEntries; i++) {
        // Get the ops container
        var container = document.getElementById(member + "_ops_graph_" + i);
        var keys = Object.keys(entries[member]);
        // Get a document
        var server = entries[member][keys[0]][i].server;
        
        // Draw graph
        var drawGraph = function(_i, _server) {
          var lastMeasurement = null;
          
          // Create the groups
          var groups = groupNames.map(function(x) {
            return {id: x, content: x, options: {}};
          });

          generateGraph(container, groups, entries[member], function(data) {
            // Locate the opcounters
            var opcounters = null;

            for(var i = 0; i < data.length; i++) {
              if(data[i].server == _server) {
                opcounters = data[i].result.opcounters;
                break;
              }
            }

            // Throw away the first result
            if(lastMeasurement == null) {
              lastMeasurement = opcounters;
              return null;
            }

            // Final Ops counters
            var finalValues = {}
            // Calculate the diff between the two (actual ops that happened)
            for(var name in opcounters) {        
              finalValues[name] = opcounters[name] - lastMeasurement[name];
            }

            // Update last measurement
            lastMeasurement = opcounters;
            // Return the values
            return finalValues;
          });
        }

        // Draw
        drawGraph(i, server);
      }
    }
  <% } %>
</script>